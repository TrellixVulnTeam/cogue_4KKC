#!/usr/bin/env python

# Copyright (C) 2014 Atsushi Togo
# All rights reserved.
#
# This file is part of cogue.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# * Neither the name of the phonopy project nor the names of its
#   contributors may be used to endorse or promote products derived
#   from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import sys
import numpy as np

try:
    import yaml
except ImportError:
    print("You need to install python-yaml.")
    sys.exit(1)
    
try:
    from yaml import CLoader as Loader
    from yaml import CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

from phonopy.units import VaspToTHz



def get_plot_data(data):
    segment_positions = []
    eigenvalues = []
    distances = []
    npoints = data['nkpoint'] / data['npath']
    efermi = data['fermi-energy']

    for j, v in enumerate(data['path']):
        eigenvalues.append([f['eigenvalue'] - efermi for f in v['band']])
        distances.append(v['distance'])
        
        if j % npoints == 0:
            segment_positions.append(v['distance'])

    return distances, eigenvalues, segment_positions


# Parse options
from optparse import OptionParser
parser = OptionParser()
parser.set_defaults(e_max=None,
                    e_min=None,
                    is_gnuplot=False,
                    is_points=False,
                    is_vertial_line=False,
                    output_filename=None,
                    symbols=None,
                    ylabel=None,
                    show_legend=False,
                    title=None)
parser.add_option("--emax", dest="e_max", type="float",
                  help="Maximum frequency plotted")
parser.add_option("--emin", dest="e_min", type="float",
                  help="Minimum frequency plotted")
parser.add_option("--gnuplot", dest="is_gnuplot", action="store_true",
                  help="Output in gnuplot data style")
parser.add_option("--legend", dest="show_legend",
                  action="store_true",
                  help="Show legend")
parser.add_option("--line", "-l", dest="is_vertial_line",
                  action="store_true",
                  help="Vertial line is drawn at between paths")
parser.add_option("-o", "--output", dest="output_filename",
                  action="store", type="string",
                  help="Output filename of PDF plot")
parser.add_option("--symbols", dest="symbols", action="store", type="string",
                  help="Show symbols at band segments")
parser.add_option("--ylabel", dest="ylabel", action="store", type="string",
                  help="")
parser.add_option("--points", dest="is_points",
                  action="store_true",
                  help="Draw points")
parser.add_option("-t", "--title", dest="title", action="store",
                  type="string", help="Title of plot")
(options, args) = parser.parse_args()

if not options.is_gnuplot:
    import matplotlib.pyplot as plt
    if options.symbols:
        from matplotlib import rc
        rc('text', usetex=True)

colors = ['b-', 'g-', 'r-', 'c-', 'm-', 'y-', 'k-',
          'b--', 'g--', 'r--', 'c--', 'm--', 'y--', 'k--']
if options.is_points:
    colors = [x + 'o' for x in colors]

count = 0

if len(args) == 0:
    filenames = ['band.yaml']
else:
    filenames = args

if options.is_gnuplot:
    print("# distance  eigenvalue (bands are separated by blank lines)")

for i, filename in enumerate(filenames):
    string = open(filename).read()
    data = yaml.load(string, Loader=Loader)
    distances, eigenvalues, segment_positions = get_plot_data(data)

    if options.is_gnuplot:
        text = "# segments:"
        for v in segment_positions:
            text += "%10.8f" % v
        text += "%10.8f" % distances[-1]
        print(text)
        
    elif options.is_vertial_line and len(filenames) == 1:
        for v in segment_positions[1:]:
            plt.axvline(x=v, linewidth=0.5, color='b')

    for j, eigvals in enumerate(np.array(eigenvalues).T):
        if options.is_gnuplot:
            for d, f in zip(distances, eigvals):
                print("%f %f" % (d, f))
            print("")
        else:
            if j==0:
                plt.plot(distances, eigvals, colors[i], label=filename)
            else:
                plt.plot(distances, eigvals, colors[i])

    if options.is_gnuplot:
        print("")

    
if not options.is_gnuplot:
    if options.ylabel:
        plt.ylabel(options.ylabel)
    else:
        plt.ylabel('Energy')
    plt.xlabel('Wave vector')
    plt.xlim(distances[0], distances[-1])
    if not options.e_max == None:
        plt.ylim(ymax = options.e_max)
    if not options.e_min == None:
        plt.ylim(ymin = options.e_min)
    plt.axhline(y=0, linestyle=':', linewidth=0.5, color='b')
    if len(filenames) == 1:
        xticks = segment_positions + [distances[-1]]
        if options.symbols:
            symbols = [x for x in options.symbols.split()]
            if len(symbols)==len(xticks):
                plt.xticks(xticks, symbols)
            else:
                print("Numbers of symbols and band segments don't match.")
                sys.exit(1)
        else:
            plt.xticks(xticks, [''] * len(xticks))
    else:
        plt.xticks([])
    
    if not options.title == None:
        plt.title(options.title)

    if options.show_legend:
        plt.legend()
    
    if not options.output_filename == None:
        plt.rcParams['pdf.fonttype'] = 42
        plt.rcParams['font.family'] = 'serif'
        plt.savefig(options.output_filename)
    else:
        plt.show()
    

